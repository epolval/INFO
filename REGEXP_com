 ##########################################
#         SYMBOLS&METASYMBOLS
########################################## 
 
 // - all regulars rounded thees symbols

 . - any symbols

 \. - serch "." with symbol "\" "." is not special but common symbol
 

##########################################
#           SYMBOL CLASSES
########################################## 

 /[a-z]/, /[0-9]/,  symbol classes
 
 /[af-]/ -serch only letters a and f and "-"
 
 /[^af-]/ -serch all symbols except a and f and "-"
 
 /[A-z]/ - all leters,numbers and symbols
 
 /[A-Za-z]/ -both capital and small leters 
 
 /\d/ - class all numbers
 
 /\D/ - all not numbers
 
 /\w/ -all leters all numbers and "_"
 
 /\W/ - all not leters , numbers and "_"
 
 ^ - on start position means the start of string
 
 
##########################################
#       POSITION INSIDE STRING
########################################## 
 
 /^java/ - find "java" only if "java" will be on start position in string
 
 /java$/ - find "java" only if "java" will be on last position in string
 
 /a\b/ -serch all "a" in last position of word
 
 /a\B/ -serch all "a" NOT in last position of word
 
 /\ba/ -serch all "a" in first position of word
 
 /\Ba/ -serch all "a" NOT in first position of word
 
 
##########################################
#              ALTERNATIVE
########################################## 

/gray|blue/ - will serch "gray" or "blue"

/gray|grow/  - will serch "gray" or "grow"

also /gr(ay|ow)/ - will serch "gray" or "grow"
 
 
##########################################
#              CVANTIFICATION
##########################################  

***************
*      ?
***************
?. Он обозначает «поиск совпадений с повторением от ноля до одного раза»:

В случае с группировкой — проверка вхождения всей группы ноль или один раз
В случае с символьным классом — проверка вхождения ноль или один раз одного из символов, но не всех одновременно

***************
*      +
***************
+. Предшествующий ему символ, группа или класс символов, должны встречаться как минимум один раз.

***************
*      *
***************

* говорит об отсутствии повторений или о повторении один или несколько раз.

***************
*     {n}
***************
/somth{2}/ h will be repeat 2 times:
 
 for ex:
 somthhing

Есть более точные квантификаторы, которые записываются в фигурных скобках {}. Достаточно указать в них необходимое число повторений
 
По умолчанию в регулярных выражениях квантификация жадная, поэтому мы захватываем максимальную подстроку.
В противоположность жадной квантификации существует ленивая. В ленивой мы захватываем минимальную подстроку. Чтобы из жадной квантификации сделать ленивую, нужно использовать специальный символ "?": 

/<.*?>/   
 
 
##########################################
#       Группировка и обратная связь
##########################################   
 
совпадают подстроки с одинаковыми левыми и правыми частями: 
 /(ta|tu)-\1/ 
 
 ta-tu ta-ta tu-tu

По умолчанию все созданные группы символов записываются в специальную область 
памяти и маркируются символами от \1 до \9. 

Гораздо проще пользоваться именами. Для этого нужно добавить ?<имя> после открытия скобки:
/(?<group1>ta|tu)-\k<group1>/
 
Мы можем отключить обратную связь, поставив ?: внутри нашей группы:
/(?:ta|tu)-\1/ 
После этого группа перестанет сохраняться в специальную область памяти. При ее вызове 
возникнет ошибка, потому что такой группы в памяти не существует. При таком подходе регулярное выражение 
становится очень сложно читать, однако оно работает быстрее.

Это вполне рабочий метод. Он особенно подходит, если вы хотите, чтобы лишние группы не занимали много места 
и не мешали заниматься дальнейшей группировкой.
 
 
##########################################
#             Модификаторы 
########################################## 

Модификаторы — это символы, которые указываются после знака ? в группе символов регулярного выражения и меняют их поведение.

Если после ? мы поставим i, то включим режим игнорирования регистра. Мы получим сопоставление еще одной подстроки, но уже не с t в нижнем регистре, а с T в верхнем:

/(?i:t.)-(?:t.)/

ta-tu ta-t

Tu-tu tu-T 

s-  делает так, что точка начинает включать в себя перевод строки и возврат каретки.

/(?i:t.)-(?si:t.)/

ta-tu ta-t

Tu-Tu tu-T

m -multiline mode

Модификаторы могут быть отключены. Для этого достаточно указать перед ними -.
 
########################################## 
#     Просмотр вперед и назад—
########################################## 

Tакое поведение называется позитивным просмотром вперед или позитивным опережающим поиском.
Логику позитивного просмотра вперед можно описать следующим образом. Регулярное выражение 
a(?=b) находит совпадения таких a, за которыми следует b, при этом не делая b частью сопоставления. 
 
 /Ludovic(?=XVI)/

LudovicXV, LudovicXVI, LudovicXVIII, LudovicLXVII, LudovicXXL
 
Просмотр вперед также может быть негативным. Тогда он будет искать совпадения в тех подстроках, 
где указанная в скобках часть подстроки отсутствует. В нашем случае, это по-прежнему XVI. 
Чтобы из позитивного просмотра сделать негативный, заменим символ = на !.

/Ludovic(?!XVI)/

LudovicXV, LudovicXVI, LudovicXVIII, LudovicLXVII, LudovicXXL 

Кроме просмотра вперед, существует просмотр назад или ретроспективный поиск. 
Он работает похожим образом, но ищет совпадения символов, расположенных после 
сгруппированной в скобках части регулярного выражения, которая не будет включена в сопоставление.

Иными словами, при позитивном просмотре назад регулярное выражение (?<=b)a находит 
совпадения таких a, перед которыми находится b, не делая b частью сопоставления.

Для позитивного просмотра назад используется дополнительный знак <. В этом примере 
мы находим совпадения подстрок Two, перед которыми следует One:

/(?<=One )Two/

One Two, Three Two
 
OR

/(?<!One )Two/

One Two, Three Two

 
########################################## 
#          Поиск по условию—
##########################################

Эта конструкция напоминает тернарный оператор из языков программирования и 
выглядит следующим образом: (?ifthen|else).

/(?(?<=a)m|p)/

mam,pap

Мы видим внешние скобки с ?, а внутри — два отдельных выражения:
Первое — это условие (?<=a). Оно проверяет, соответствует ли символ слева a
Дальше идет альтернатива. Мы выбираем между m и p в зависимости от того, сработало условие или нет 
«Найти все m перед которыми идет a, или все p, перед которыми a нет». 


########################################## 
#                Flags
##########################################
g -flag g means we grab all string aa aa aa not only first "aa"(by default): 

/aa        /g 

aa aa aa

флаг /i, который включает режим игнорирования регистра
флаг /s. Он включает соответствие метасимвола . переводу строки




 
