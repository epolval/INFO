##################################
#    MAIN COMMANDS
##################################

#Для начала создадим базу данных для школы Хекслет с помощью такой команды:
CREATE DATABASE hexlet_db;

#Чтобы создать таблицу, нужно выполнить такой запрос:
CREATE TABLE users (
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    email VARCHAR(255),
    created_at TIMESTAMP);
    
#Теперь мы можем добавить нескольких пользователей в таблицу:
INSERT INTO users
(first_name,  last_name, email, created_at)
VALUES ('Lucienne', 'Feil',  'Trevion53@yahoo.com', '2022-06-14 18:31:05.296'); 

#Давайте исправим эту ошибку. Напишем запрос на редактирование записи:
UPDATE users SET email = 'Casimer_Cronin@gmail.com' WHERE last_name = 'Romaguera'; 

#Еще одна достаточно частая операция — удаление записей. 
#Давайте удалим нашего пользователя из таблицы:
DELETE FROM users WHERE last_name = 'Romaguera';

##################################
#Подключение к БД с помощью psql
##################################

#Для начала, чтобы подключиться к базе данных с помощью psql, необходимо выполнить команду:
psql -h server_address -U username -d dbname

Таблицы—

#Для строк в базах данных в основном используются два типа:
#varchar(n) — для строк с ограничением максимальной длины
#text — для строк без ограничения. Как правило, это полноценные тексты
    
#ex:
CREATE TABLE topics (title varchar(255),body text);    
    
    
integer
типичный выбор для целых чисел
-2147483648 .. +2147483647

bigint
целое в большом диапазоне
-9223372036854775808 .. 9223372036854775807

real
вещественное число с переменной точностью
-2147483648 .. +2147483647, точность в пределах 6 десятичных цифр 

timestamp
дата и время (без часового пояса)
4713 до н. э.
294276 н. э.
1 микросекунда

date
дата (без времени суток)
4713 до н. э.
5874897 н. э.
1 день

time
время суток (без даты)
00:00:00
24:00:00
 1 микросекунда

##################################    
# Первичный ключ и автоинкремент
################################## 

#column_name type PRIMARY KEY GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY[ ( sequence_option ) ]
#Тип данных может быть SMALLINT, INT или BIGINT
#GENERATED ALWAYS — не позволит добавлять значение самостоятельно, используя UPDATE или INSERT
#GENERATED BY DEFAULT — в отличие от предыдущего варианта, этот вариант позволяет добавлять значения самостоятельно

for ex:
CREATE TABLE users (
    -- Одновременное использование и первичного ключа и автогенерации
    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    username VARCHAR(50),
    email VARCHAR(255),
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    created_at TIMESTAMP
);

##################################   
#           SELECT
##################################

SELECT first_name, email, username FROM users;    

##################################    
#     SELECT WITH CONDITIONS
##################################

SELECT * FROM users WHERE id > 60;
= — равно

!= — не равно

> — больше

< — меньше

>= — больше либо равно, не меньше

<= — меньше либо равно, не больше    
    
##################################
#Обработка особых значений
##################################

#Правильный запрос будет выглядеть так:

SELECT * FROM users WHERE birthday IS NOT NULL;
#OR
SELECT * FROM users WHERE birthday IS NULL;

##################################    
#Фильтрация строк
##################################

#Для фильтрации текста по шаблону используется оператор LIKE, 
#после которого мы указываем шаблон. В нашей задаче мы хотим 
#найти людей, чьи фамилии начинаются на "Sch", поэтому шаблон 
#будет выглядеть так:

SELECT id, first_name, last_name, email, birthday FROM users WHERE last_name LIKE 'Sch%'; 
#OR
SELECT id, first_name, last_name, email, birthday FROM users WHERE last_name NOT LIKE '%man';

#    % - любое количество любых символов 
#Чтобы не задумываться о регистре букв в шаблоне можно воспользоваться оператором ILIKE, 
#который ищет строки без учета регистра   
    
##################################     
#Регулярные выражения
################################## 
    
#Для работы с регулярными выражениями используется оператор SIMILAR TO вместо LIKE.    
    
#for ex:
SELECT
    id,
    first_name,
    last_name,
    email,
    birthday
FROM users
WHERE first_name SIMILAR TO '[AB]%';    
    
#Символ подчеркивания обозначает ровно один любой символ, 
#необязательно букву. Наш запрос будет выглядеть так:

SELECT
    username,
    email
FROM users WHERE email SIMILAR TO '%@%.__';  

#Символ % соответствует любому количеству любых символов
#Квадратные скобки [] используются для перечисления конкретных символов — например, [АЕИОУЭЮ]
#Дефис - в квадратных скобках означает перечисление символов — например, [0-9] соответствует любой цифре
#Подчеркивание _ означает ровно один любой символ (букву или цифру) 


###########################
#   Основы SQL
###########################

#Если понадобится десяток совпадений, можно использовать оператор IN. 
#После него в скобках через запятую нужно указать значения, 
#которым должно быть равно поле в запросе:

SELECT id, first_name, last_name FROM users WHERE id IN (1, 2, 5);     #EXIST IN LIST
SELECT id, first_name, last_name FROM users WHERE id NOT IN (1, 2, 5); #NOT IN LIST

###########################
#   Сортировка данных
###########################

#Сортировка задается с помощью оператора ORDER BY. За ней следует имя поля, 
#по которому происходит сортировка:

SELECT id, username, created_at FROM users ORDER BY username;                            #in forward direction
SELECT id, username, created_at FROM users ORDER BY username DESC;                       #in backward direction
SELECT first_name, last_name, salary FROM staff ORDER BY salary DESC, first_name ASC;    #ordered by several fields

#sorting with NULL values

-- Поля с `NULL` идут первыми:
SELECT id, username, created_at FROM users ORDER BY created_at ASC NULLS FIRST;

-- Поля с `NULL` идут последними:
SELECT id, username, created_at FROM users ORDER BY created_at DESC NULLS LAST;

###########################
#  Ограничение выборки
###########################

#нужно извлечь 10 записей. Для этого выполним такой запрос:
SELECT id, username, email FROM users LIMIT 10;

#Выбрать записи с 21 по 30
SELECT id, username, email FROM users ORDER BY id LIMIT 10 OFFSET 20;
 
    
    
    
